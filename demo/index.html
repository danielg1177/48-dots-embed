<html>
<head>
    <title>Demo page of the widget</title>
</head>
<body>
    <h1>Lorem ipsum dolor sit amet augue</h1>
    <h2>Fusce gravida vehicula vestibulum tortor pulvinar</h2>
    <div id="embed_container" class="flex items-center">
        <p class="embed_text">I want to </p>
        <div class="relative flex">
            <div class="flex items-end">
                <p id="stay_button" class="embed_button" onClick="toggleStayDropdown()">stay</p>
                <span style="font-size: 37px;">,</span>
            </div>
            <div id="stay-dropdown" class="embed_dropdown">
                <p onClick="selectStay('swap')" class="stay-option">Swap</p>
                <p onClick="selectStay('book')" class="stay-option">Book</p>
                <p onClick="selectStay('points')" class="stay-option">Use Points</p>
            </div>
        </div>

        <div class="relative flex">
            <p id="location_button" class="embed_button" onClick="toggleLocationDropdown()">anywhere</p>
            <div id="location-dropdown" class="embed_dropdown">
                <form autocomplete="off" action="/action_page.php">
                    <div class="autocomplete">
                      <input id="location-input" type="text" name="location-input" placeholder="Search by location">
                    </div>
                </form>
            </div>
        </div>

        <input id="start" />
        <input id="end" />
    </div>


    <p>Orci purus ante excepteur nunc nascetur rhoncus taciti ut. Ornare vitae sed. Amet suspendisse integer rutrum aliquet
        venenatis. Nec sed nullam mauris magna vel pretium non tristique. Porta justo ac dictumst aliquip blandit. Libero
        nec eu dolor eget volutpat. Magna nulla neque. Fames tempus lorem duis orci ipsum.</p>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@300;400;700&display=swap');

        .embed_text {
            color: #9846B7;
            font-size:37px;
            font-weight: 700;
            font-family: "Roboto", sans-serif;
            margin: 0;
        }

        .embed_dropdown {
            position: absolute;
            background-color: white;
            top: 60px;
            right: 5px;
            box-shadow: none;
            padding: 0;
            height: 0;
            overflow: hidden;
            transition-duration: 200ms;
        }

        #stay-dropdown {
            width: 130px;
            max-width: 130px;
        }

        #location-dropdown {
            width: 400px;
            max-width: 400px;
        }

        .stay-dropdown-open {
            height: auto !important;
            box-shadow: 1px 1px 1px 1px rgb(0 0 0 / 20%), 1px 1px 1px 1px rgb(0 0 0 / 14%), 1px 1px 1px 1px rgb(0 0 0 / 12%) !important;
        }

        .location-dropdown-open {
            height: 350px !important;
            box-shadow: 1px 1px 1px 1px rgb(0 0 0 / 20%), 1px 1px 1px 1px rgb(0 0 0 / 14%), 1px 1px 1px 1px rgb(0 0 0 / 12%) !important;
            overflow-y: auto;
        }

        .stay-option {
            padding: 10px 23px;
            margin: 6px 0;
            cursor: pointer;
        }

        .stay-option:hover {
            background-color: rgb(225, 224, 224);
        }

        .embed_button {
            font-size:27px;
            font-weight: 600;
            font-family: "Roboto", sans-serif;
            padding: 10px 17px;
            border: thin solid currentColor;
            border-radius: 6px;
            margin: 0 0 0 10px;
            cursor: pointer;
        }

        .autocomplete {
            /*the container must be positioned relative:*/
            position: relative;
            display: inline-block;
            width: 100%;
        }
        #location-input {
            border: 1px solid transparent;
            background-color: #f1f1f1;
            padding: 10px;
            font-size: 16px;
        }
        #location-input[type=text] {
            background-color: #f1f1f1;
            width: 100%;
        }
        .autocomplete-items {
            position: absolute;
            border: 1px solid #d4d4d4;
            border-bottom: none;
            border-top: none;
            z-index: 99;
            /*position the autocomplete items to be the same width as the container:*/
            top: 100%;
            left: 0;
            right: 0;
        }
        .autocomplete-items div {
            padding: 10px;
            cursor: pointer;
            background-color: #fff;
            border-bottom: 1px solid #d4d4d4;
        }
        .autocomplete-items div:hover {
            /*when hovering an item:*/
            background-color: #e9e9e9;
        }
        .autocomplete-active {
            /*when navigating through the items using the arrow keys:*/
            background-color: DodgerBlue !important;
            color: #ffffff;
        }

        .relative {
            position: relative;
        }

        .flex {
            display: flex;
        }

        .items-center {
            align-items: center;
        }

        .items-end {
            align-items: end;
        }

        .desky-cal-hidden {
            display: none !important;
        }
        .deskycal {
            width: min-content;
        }

        .deskycal input {
            cursor: pointer;
            height: 22px;
            padding-left: 25px;
            /* background: url("../icons/calendar.png") no-repeat left; */
            background-position-x: 1px;
            background-size: 20px;
            color: #999;
            background-color: #fcfcfc;
        }

        .deskycal input:hover {
            background-color: #ffffd6;
        }

        .desky-cal-container {
            font-family: "Roboto Condensed";
            color: #ddd;
            position: absolute;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            user-select: none;
            border: 1px solid #7b7a7a;
            background-color: #0c0d2b;
            border-radius: 5px;
            width: 400px;
            z-index: 9;
            overflow: auto;
        }

        .desky-cal-container .left {
            border-right: 1px solid #333;
            margin: 2em 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
        }

        .desky-cal-container .right {
            position: relative;
            margin: 2em 0 ;
            text-align: center;
        }
        .desky-cal-container .left-day {
            font-size: 4em;
            line-height: 1em;
            cursor: pointer;
        }
        .desky-cal-container .left-today {
            font-size: 0.8em;
        }


        .desky-cal-container .desky-arrow {
            color: white;
            font-weight: 800;
            cursor: pointer;
        }

        .desky-cal-container .desky-cal-month-name,
        .desky-cal-container .desky-cal-dow-list {
            color: coral;
        }



        .desky-cal-container .desky-cal-right-header {
            display: grid;
            grid-template-columns: 1fr 3fr 1fr;
            gap:0;
            line-height: 35px;
        }

        .desky-cal-container .desky-cal-right-bottom{
            margin: 0.1em 1em;
        }
        .desky-cal-container .desky-cal-right-bottom > div {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
            gap:0;
            font-size: 0.8em;

        }
        .desky-cal-container .desky-cal-right-bottom div.desky-cal-dow-list {
            border-bottom: 1px solid #333;
            margin: 3px 0;
        }

        .desky-cal-container .desky-cal-daylist {
            line-height: 1.4rem;
            margin: 0.8rem 0 0 0;
        }

        .desky-cal-container .last-month,
        .desky-cal-container .next-month,
        .desky-cal-container .curr-month.disabled {
            color: #444;
        }

        .desky-cal-container .curr-month:not(.disabled) {
            color: #bbb;
            cursor: pointer;
        }

        .desky-cal-container .curr-month.today {
            background-color: #763000;
            color: #eee;
            border-radius: 7px;
        }

        .desky-cal-container .curr-month:not(.disabled):hover,
        .desky-cal-container .desky-arrow:hover,
        .desky-cal-container .desky-cal-close:hover {
            color: coral;
        }

        .desky-cal-container .left:hover {
            color: #bbb;
        }

        .desky-cal-container .desky-cal-close {
            font-family: sans-serif;
            position: absolute;
            left: 10px;
            top: 10px;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
        }


        .desky-cal-container.single {
            width: 200px;
            grid-template-columns: 1fr;
        }
        .desky-cal-container.single .desky-cal-daylist {
            line-height: 1rem;
            margin: 0.8rem 0 0 0;
        }

        .desky-cal-container.white {background-color: #eaeaea; }
        .desky-cal-container.white .last-month {color: #aaa; }
        .desky-cal-container.white .curr-month {color: #666; cursor: pointer; }
        .desky-cal-container.white .arrow {color: #666; }

        .desky-cal-container .right .clicked {
            background-color: coral;
            color: #333 !important;
            border-radius: 7px;
        }

        @media only screen and (max-width: 600px) {
            .deskycal input {
                font-size: 16px;
            }
            .desky-cal-container {
                grid-template-columns: 1fr;
            }
            .desky-cal-container .left {
                display: none !important;
            }

        }

        @media only screen and (max-width: 1100px) {
            .desky-cal-container .curr-month:hover, .desky-cal-container .desky-arrow:hover, .desky-cal-container .desky-cal-close:hover {
                color: #333;
            }
            .desky-dark-container {
                position: fixed;
                top: 0;
                left: 0;
                background-color: #00000088;
                width: 100%;
                height: 100%;
                z-index: 9;
            }
            .desky-cal-container, .desky-cal-container.single {
                max-width: 500px;
                width: 90vw;
                max-height: 88vh;
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                font-size: 22px;
                height: 400px;
            }

            .desky-cal-container .right {
                margin: auto 1em;
            }
            .desky-cal-container .left {
                border-right: none;
                margin: 10px auto;
                display: flex;
                flex-direction: column;
                justify-content: center;
                text-align: center;
            }


            .desky-cal-container .desky-cal-right-bottom > div {
                font-size: 24px;
                line-height: 24px;
                gap: 11px;
            }

            .desky-cal-container .desky-cal-right-header {
                line-height: 55px;
                font-size: 22px;
            }
            .desky-arrow {
                font-size: 30px;
            }

            .desky-cal-container .last-month, .desky-cal-container .next-month  {
                color: #444;
            }

            .desky-cal-container .desky-cal-close {
                left: 10px;
                top: 15px;
                font-size: 40px;
            }
        }
    </style>
    <script>
        // (function (w,d,s,o,f,js,fjs) {
        //     w['JS-Widget']=o;w[o] = w[o] || function () { (w[o].q = w[o].q || []).push(arguments) };
        //     js = d.createElement(s), fjs = d.getElementsByTagName(s)[0];
        //     js.id = o; js.src = f; js.async = 1; fjs.parentNode.insertBefore(js, fjs);
        // }(window, document, 'script', 'mw', './widget.js'));

        const deskyOpts = {};
        const options = {};

        function app(window) {
            console.log('starting');

            // let entrance = document.getElementById('embed_container');
            // entrance.innerHTML = "";

            initDeskyCalendar("start", "single", null, null, "end");
            initDeskyCalendar("end", "single");
        }

        function toggleStayDropdown() {
           let stayDropDown = document.getElementById('stay-dropdown');
           if (stayDropDown.classList.contains('stay-dropdown-open')) {
               stayDropDown.classList.remove('stay-dropdown-open');
           } else {
               stayDropDown.classList.add('stay-dropdown-open');
           }
        }

        function toggleLocationDropdown() {
           let stayDropDown = document.getElementById('location-dropdown');
           if (stayDropDown.classList.contains('location-dropdown-open')) {
               stayDropDown.classList.remove('location-dropdown-open');
           } else {
               stayDropDown.classList.add('location-dropdown-open');
           }
        }

        function selectStay(opt) {
            options['stay'] = opt;
            toggleStayDropdown()
            let stayDropDown = document.getElementById('stay_button');
            stayDropDown.innerText = opt;
        }

        function initDeskyCalendarAll() {
            if (Object.keys(deskyOpts).length == 0) {console.log("Init deskyOpts Object beforer using this function"); return;}

            Array.from(Object.keys(deskyOpts)).forEach(function(k){
                let input = document.getElementById(k);
                let containerHtml = "<dxv id='deskycal_container_"+k+"' class='deskycal'></dxv>";
                /// This gives a #document, get first child
                let container = parseHTML(containerHtml);
                let newParent = container.firstChild;

                let newInput = input.cloneNode(true);
                let parent = input.parentNode;

                newParent.appendChild(newInput);
                parent.replaceChild(newParent, input);

                //set input property and event listener
                newInput.readOnly = true;
                newInput.addEventListener('click', function(e){showCalSel(e,this); });


                // set input date to show, if not any date.
                let curr_month, curr_year;
                let in_date = deskyOpts[k]['in_date'];
                if (!deskyOpts[k]['any_date']) {
                    let inDate = new Date();
                    if (in_date > 1000) {
                        // console.log("mills "+mills)
                        inDate.setTime(in_date);
                        curr_month = inDate.getMonth();
                        curr_year = inDate.getFullYear();
                        deskyOpts[k].in_date=inDate.getTime();
                    }

                    // date format just in US format right now
                    newInput.value = inDate.getFullYear()+"-"+String(parseInt(inDate.getMonth())+1).padStart(2,"0")+"-"+String(inDate.getDate()).padStart(2,'0')
                } else newInput.value = "Select";

                // Prepare disabled dates, if any. Will be used in draw schema
                let disDate = new Date();
                let disabled_before = deskyOpts[k]['disabled_before'];
                if (disabled_before > 1000) {
                    disDate.setTime(disabled_before);
                    deskyOpts[k].disabled_before=disDate.getTime()+86400000;
                }

                // init and draw calendars with inDate month and year
                insertSchema(newParent, k);
                drawCalSel(newParent, k, curr_year, curr_month);
            })
        }

        function initDeskyCalendar(id, mode = 'double', in_date = null, any_date = false, next_input = null, disabled_before=null, disabled_after=null, scroll=false, callback = null) {
            let cb;
            let input = document.getElementById(id);
            if (input == null) {
                console.log("[deskyCal] input id "+id+" not found");
                return;
            }

            /// Check Inputs
            if (mode == null) mode="double";
            if (!['double', 'single'].includes(mode)) console.log('[deskyCal] "mode" not valid; "single" or "double" are valid');
            if (in_date < 0) console.log('[deskyCal] timestamp can\'t be negative');

            /// Create Options Object
            deskyOpts[id] = {
                'mode':mode,
                'in_date':in_date,
                'any_date':any_date,
                'next_input':next_input,
                'disabled_before':disabled_before,
                'disabled_after':disabled_after,
                'callback': callback,
                'scroll':scroll
            };

            let containerHtml = "<div id='deskycal_container_"+id+"' class='deskycal'></div>";

            /// This gives a #document, get first child
            let container = parseHTML(containerHtml);
            let newParent = container.firstChild;

            let newInput = input.cloneNode(true);
            let parent = input.parentNode;

            newParent.appendChild(newInput);
            parent.replaceChild(newParent, input);

            //set input property and event listener
            newInput.readOnly = true;
            newInput.addEventListener('click', function(e){showCalSel(e,this); });

            // set input date to show, if not any date.
            let curr_month, curr_year;
            if (!any_date) {
                let inDate = new Date();
                if (in_date > 1000) {
                    // console.log("mills "+mills)
                    inDate.setTime(in_date);
                    curr_month = inDate.getMonth();
                    curr_year = inDate.getFullYear();
                    deskyOpts[id].in_date=inDate.getTime();
                }

                // date format just in US format right now
                newInput.value = inDate.getFullYear()+"-"+String(parseInt(inDate.getMonth())+1).padStart(2,"0")+"-"+String(inDate.getDate()).padStart(2,'0')
            } else newInput.value = "Select";

            // Prepare disabled dates, if any. Will be used in draw schema
            let disDate = new Date();
            if (disabled_before > 1000) {
                disDate.setTime(disabled_before);
                deskyOpts[id].disabled_before=disDate.getTime()+86400000;
            }

            // init and draw calendars with inDate month and year
            insertSchema(newParent, id);
            drawCalSel(newParent, id, curr_year, curr_month);

            return;
        }

        function insertSchema(parent, id) {
            let el = "";
            let extraClass= "";
            if (deskyOpts[id].mode == "single") extraClass = "single";
            el+= "<div class='desky-dark-container desky-cal-hidden'>";
            el+= "	<div class='desky-cal-container  "+extraClass+"' id='deskycal_"+id+"'>";
            // X to close
            el+= "		<span class='desky-cal-close' onclick='closeCalSel()'>X</span>";
            if (deskyOpts[id].mode == "double") {
                // Left -- Big Date
                el+= "		<div class='left' onClick='dayClick(this)'>";
                el+= "			<span class='left-today'>Today</span> <span class='left-day'></span> <span class='left-mon'></span>";
                el+= "		</div>";
            }
            // Right -- Calendar
            el+= "		<div class='right'>";
            // Header
            el+= "			<div class='desky-cal-right-header arrows'>";
            el+= "				<span class='desky-arrow' onclick='calSelPrev(this)'><</span>";
            el+= "				<span class='desky-cal-month-name'></span>";
            el+= "				<span class='desky-cal-month-num desky-cal-hidden' ></span>";
            el+= "				<span class='desky-arrow' onclick='calSelNext(this)'>></span>";
            el+= "			</div>";
            // Daylist
            el+= "			<div class='desky-cal-right-bottom'>";
            el+= "				<div class='desky-cal-dow-list'></div>";
            el+= "				<div class='desky-cal-day-list'> </div>";
            el+= "			</div>";
            // AnyDate
            if (deskyOpts[id].any_date) {
                el+="			<span data-day='calsel_anyDate_"+id+"' class='curr-month cal-sel-day' onClick='dayClick(this)'>Any Date</span>";
            }
            // Close right
            el+= "		</div>";
            el+= "	</div>";
            el+= "</div>";
            // console.log(el);

            /// Create the node and append in parent
            let node = parseHTML(el);
            parent.appendChild(node);

            // INIT all weekdays in localestring format and set, it creates dows string with spans with S M T W T F S
            let tdate = new Date();
            tdate.setYear(2021);
            tdate.setMonth(8);
            let dows = "";
            for (let i=1; i<=21; i++) {
                tdate.setDate(i);
                if (dows.length != 0) dows += "<span>"+tdate.toLocaleString('default', { weekday: 'long' }).charAt(0)+"</span>";
                if (tdate.getDay() == 0) dows += "<span>"+tdate.toLocaleString('default', { weekday: 'long' }).charAt(0)+"</span>";
                if (tdate.getDay() == 6 && dows.length != 0) break;
                // console.log(i+"--"+dows);
            }
            // console.log("dows:"+dows);
            parent.querySelector('.desky-cal-dow-list').innerHTML = dows;

            // End weekdays
        }


        function drawCalSel(calParent, inputId, curr_year, curr_month) {
            // console.log(calParent);

            // // let inputId = calParent.id.split("_").slice(2).join("_");
            // console.log(calParent.id);
            // console.log(inputId);
            // console.log(curr_month+" "+curr_year);
            let today = new Date();
            let tdate = new Date();
            let out="";
            let tid = "";

            let monthNameSpan = calParent.querySelector('.desky-cal-month-name');
            let monthNumSpan = calParent.querySelector('.desky-cal-month-num');
            let calContainer = calParent.querySelector('.desky-cal-day-list');

            if ( isNaN(curr_year)) curr_year = today.getFullYear();
            if ( isNaN(curr_month)) curr_month = today.getMonth();

            let first = new Date(curr_year, curr_month, 1);
            let last = new Date(curr_year, curr_month+1, 0);
            let dowFirst = first.getDay();
            let dowLast = last.getDay();

            let currMonthName = first.toLocaleString('default', { month: 'long' });
            // first.getFullYear();

            // Left - Day and month - TODAY
            let tToday = new Date();

            let todayMonthName = tToday.toLocaleString('default', { month: 'long' });
            let todayTid = "calsel_"+curr_year+"_"+(parseInt(tToday.getMonth())+1)+"_"+tToday.getDate();

            if (deskyOpts[inputId].mode == "double") {
                calParent.querySelector('.left-day').innerText = today.getDate();
                calParent.querySelector('.left-mon').innerText = todayMonthName;
                calParent.querySelector('.left').dataset.day = todayTid;
            }

            // Right - month name
            monthNameSpan.innerText = currMonthName+" "+first.getFullYear();
            monthNumSpan.innerText = curr_month+"_"+curr_year; //hidden

            let humanCurrMonth=curr_month+1;

            let numFirst = first.getDate();
            let numLast = last.getDate();

            // console.log("***"+first+"*** ----> "+dowFirst+" month:"+curr_month+" year:"+curr_year);


            //last day of past month
            let lastLast = new Date(curr_year, curr_month, 0).getDate();

            // Past month from last sunday
            // that's obtained subtracting last day in the past month with first day of week of current month
            tdate = new Date();
            for (let i=lastLast-dowFirst+1; i<=lastLast; i++) {
                out += "<span class='last-month cal-sel-day'>"+i+"</span>";
            }

            // This month
            tdate = new	Date();
            tdate.setMonth(curr_month);
            for (let i=1; i<=numLast; i++) {
                tdate = new Date(tdate.setDate(i));
                tid = "calsel_"+curr_year+"_"+humanCurrMonth+"_"+tdate.getDate();
                let extraClass="";
                if (todayTid == tid) extraClass="today";
                /// disabled before
                if (tdate.getTime() < deskyOpts[inputId].disabled_before) extraClass="disabled";
                /// disabled after
                if (tdate.getTime() > deskyOpts[inputId].disabled_after && deskyOpts[inputId].disabled_after != null) extraClass="disabled";

                out += "<span data-day='"+tid+"' class='curr-month cal-sel-day "+extraClass+"' onClick='dayClick(this)'>"+tdate.getDate()+"</span>";
                // console.log("this: "+tdate);
            }

            for (let i=1; i<7-dowLast; i++) {
                tdate = new Date();
                tdate.setDate(i);
                tdate.setMonth(curr_month+1);
                out += "<span class='next-month cal-sel-day'>"+tdate.getDate()+"</span>";
                // console.log("next:"+tdate+" num:"+numFirst+" i:"+i+" dowLast:"+dowLast);
            }

            // **Rev1
            // Adding node should be better then innerHTML
            let node = parseHTML(out);
            while (calContainer.firstChild) calContainer.removeChild(calContainer.lastChild);
            calContainer.appendChild(node);
            // calContainer.innerHTML = out;
        }

        function calSelPrev(el) {
            let calParent = getParentByClass(el, 'desky-cal-container');
            let currA = calParent.querySelector('.desky-cal-month-num').innerText.split("_");
            let nmonth = parseInt(currA[0])-1
            drawCalSel(calParent, calParent.id.split("_").slice(1).join("_"), currA[1], nmonth);
        }

        function calSelNext(el) {
            let calParent = getParentByClass(el, 'desky-cal-container');
            let currA = calParent.querySelector('.desky-cal-month-num').innerText.split("_");
            let nmonth = parseInt(currA[0])+1;
            drawCalSel(calParent, calParent.id.split("_").slice(1).join("_"), currA[1], nmonth);
        }

        function dayClick(el) {
            // console.log(id);
            if (el.classList.contains('disabled')) return;
            el.classList.add('clicked');

            let idA = el.dataset.day.split("_");
            let parId = getParentByClass(el, 'desky-cal-container').id;
            let targetId = parId.substring(parId.indexOf("_") + 1);
            // console.log(target_id);
            let input = document.getElementById(targetId);
            let centerDate = new Date();

            if (idA[1] == "anyDate") {
                input.value = "Any";
            } else {
                centerDate.setYear(idA[1]);
                centerDate.setMonth(idA[2]-1);
                centerDate.setDate(idA[3]);
                // input.value = centerDate;
                input.value = centerDate.getFullYear()+"-"+String(parseInt(centerDate.getMonth())+1).padStart(2,"0")+"-"+String(parseInt(centerDate.getDate())).padStart(2,'0');
            }

            // call callback just if function is defined
            if (typeof deskyOpts[targetId].callback === 'function') {
                console.log("call back function");
                deskyOpts[targetId].callback(centerDate);
            }

            if (deskyOpts[targetId].next_input != null) {
                /// redraw next input
                let nextInput = deskyOpts[targetId].next_input;
                let nextInputParent = document.getElementById('deskycal_container_'+nextInput);
                let nextInputEl=document.getElementById(nextInput);

                deskyOpts[nextInput].disabled_before = centerDate.getTime();
                nextInputEl.value = centerDate.getFullYear()+"-"+String(parseInt(centerDate.getMonth())+1).padStart(2,"0")+"-"+String(parseInt(centerDate.getDate())).padStart(2,'0');
                drawCalSel(nextInputParent, nextInput, idA[1], idA[2]-1)
            }
            let to=300;

            setTimeout(function(){
                el.classList.remove("clicked");
                closeCalSel();
            },to)
        }

        function showCalSel(e, el){
            e.stopPropagation();
            // closeCalSel();
            // console.log(el);
            let par = el.parentNode;
            let cls = par.querySelector('.desky-dark-container');
            // let cls = document.getElementById('cal_'+el.id);
            // let par = getParentByClass(cls, 'date-selector');

            cls.classList.toggle('desky-cal-hidden');

            if (deskyOpts[el.id].scroll) {
                console.log("Scroll into view");
                cls.querySelector('.desky-cal-container').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            ///if calendar goes out of borders, position against border
            let con = par.querySelector('.desky-cal-container');
            let bottomPos = con.getBoundingClientRect()['bottom'];
            let rightPos = con.getBoundingClientRect()['right'];
            let windowHeight = window.innerHeight;
            let windowWidth = window.innerWidth;
            // console.log(rightPos+" "+windowWidth);
            if (rightPos > windowWidth) {
                con.style.right = "2px";
                // cls.style.left = "auto"
            }

            document.addEventListener('mouseup',deskyCalSelEvent)
            return;
        }

        function closeCalSel(){
            document.querySelectorAll('.desky-dark-container').forEach(function(el){
                if (!el.classList.contains('desky-cal-hidden')) {
                    el.classList.add('desky-cal-hidden');
                    return;
                }
            });
            document.removeEventListener('mouseup',deskyCalSelEvent);
        }

        function deskyCalSelEvent(e) {
            document.querySelectorAll('.deskycal').forEach(function(el){
                let cls = el.querySelector('.desky-dark-container');
                if (cls == null) return;
                if (!cls.classList.contains('desky-cal-hidden')) {
                    if (!cls.contains(e.target)) closeCalSel();
                }
            });
        }

        function getParentByClass(el, className, maxDepth=10) {
            let i=0;
            while (!el.classList.contains(className)) {
                el=el.parentElement;
                i++;
                if (i>maxDepth) return false;
            }
            return el;
        }

        function parseHTML(html) {
            // It creates a node, and not need to reload the dom with innerHTML, but can use appendChild instead.
            // Added at middle project, maybe everything could be faster js side.
            var t = document.createElement('template');
            t.innerHTML = html;
            return t.content;
        }

        let inp = document.getElementById('location-input');
        let suggestions = [
            'Athens, Greece',
            'Bali, Indonesia',
            'British Columbia, Canada',
            'California, USA',
            'Hawaii, USA',
            'Florida, USA',
            'Salto, Uruguay',
            'Split, Croatia',
            'Virginia, USA',
            'Washington, USA',
        ]

        autocomplete(inp, suggestions);

        function autocomplete(inp, arr) {
            var currentFocus;

            if (!inp.value) {
                let a = document.createElement("DIV");
                a.setAttribute("id", this.id + "autocomplete-list");
                a.setAttribute("class", "autocomplete-items");
                parent = document.getElementsByClassName('autocomplete')[0]
                parent.appendChild(a);

                for (i = 0; i < arr.length; i++) {
                    console.log(parent)
                    /*check if the item starts with the same letters as the text field value:*/
                    /*create a DIV element for each matching element:*/
                    let b = document.createElement("DIV");
                    /*make the matching letters bold:*/
                    b.innerHTML += "<p>" + arr[i] + "</p>";
                    /*insert a input field that will hold the current array item's value:*/
                    b.innerHTML += "<input type='hidden' value='" + arr[i] + "'>";
                    /*execute a function when someone clicks on the item value (DIV element):*/
                    b.addEventListener("click", function(e) {
                        /*insert the value for the autocomplete text field:*/
                        inp.value = this.getElementsByTagName("input")[0].value;
                        /*close the list of autocompleted values,
                        (or any other open lists of autocompleted values:*/
                        closeAllLists();
                    });

                    a.appendChild(b);
                }
            }
            /*execute a function when someone writes in the text field:*/
            inp.addEventListener("input", function(e) {
                var a, b, i, val = this.value;
                /*close any already open lists of autocompleted values*/
                closeAllLists();
                if (!val) { return false;}
                currentFocus = -1;
                /*create a DIV element that will contain the items (values):*/
                a = document.createElement("DIV");
                a.setAttribute("id", this.id + "autocomplete-list");
                a.setAttribute("class", "autocomplete-items");
                /*append the DIV element as a child of the autocomplete container:*/
                this.parentNode.appendChild(a);
                /*for each item in the array...*/
                for (i = 0; i < arr.length; i++) {
                    /*check if the item starts with the same letters as the text field value:*/
                    if (arr[i].substr(0, val.length).toUpperCase() == val.toUpperCase()) {
                    /*create a DIV element for each matching element:*/
                    b = document.createElement("DIV");
                    /*make the matching letters bold:*/
                    b.innerHTML = "<strong>" + arr[i].substr(0, val.length) + "</strong>";
                    b.innerHTML += arr[i].substr(val.length);
                    /*insert a input field that will hold the current array item's value:*/
                    b.innerHTML += "<input type='hidden' value='" + arr[i] + "'>";
                    /*execute a function when someone clicks on the item value (DIV element):*/
                        b.addEventListener("click", function(e) {
                        /*insert the value for the autocomplete text field:*/
                        inp.value = this.getElementsByTagName("input")[0].value;
                        /*close the list of autocompleted values,
                        (or any other open lists of autocompleted values:*/
                        closeAllLists();
                    });
                    a.appendChild(b);
                    }
                }
            });

            /*execute a function presses a key on the keyboard:*/
            inp.addEventListener("keydown", function(e) {
                var x = document.getElementById(this.id + "autocomplete-list");
                if (x) x = x.getElementsByTagName("div");
                if (e.keyCode == 40) {
                    /*If the arrow DOWN key is pressed,
                    increase the currentFocus variable:*/
                    currentFocus++;
                    /*and and make the current item more visible:*/
                    addActive(x);
                } else if (e.keyCode == 38) { //up
                    /*If the arrow UP key is pressed,
                    decrease the currentFocus variable:*/
                    currentFocus--;
                    /*and and make the current item more visible:*/
                    addActive(x);
                } else if (e.keyCode == 13) {
                    /*If the ENTER key is pressed, prevent the form from being submitted,*/
                    e.preventDefault();
                    if (currentFocus > -1) {
                    /*and simulate a click on the "active" item:*/
                    if (x) x[currentFocus].click();
                    }
                }
            });
            function addActive(x) {
                /*a function to classify an item as "active":*/
                if (!x) return false;
                /*start by removing the "active" class on all items:*/
                removeActive(x);
                if (currentFocus >= x.length) currentFocus = 0;
                if (currentFocus < 0) currentFocus = (x.length - 1);
                /*add class "autocomplete-active":*/
                x[currentFocus].classList.add("autocomplete-active");
            }
            function removeActive(x) {
                /*a function to remove the "active" class from all autocomplete items:*/
                for (var i = 0; i < x.length; i++) {
                x[i].classList.remove("autocomplete-active");
                }
            }
            function closeAllLists(elmnt) {
                /*close all autocomplete lists in the document,
                except the one passed as an argument:*/
                var x = document.getElementsByClassName("autocomplete-items");
                for (var i = 0; i < x.length; i++) {
                if (elmnt != x[i] && elmnt != inp) {
                x[i].parentNode.removeChild(x[i]);
                }
            }
            }
            /*execute a function when someone clicks in the document:*/
            // document.addEventListener("click", function (e) {
            //     closeAllLists(e.target);
            // });
        }

        window.addEventListener("load", (event) => {
            app(window);
        });
    </script>
    <!-- <script src="./widget.js" type="text/javascript"></script> -->
</body>
</html>
